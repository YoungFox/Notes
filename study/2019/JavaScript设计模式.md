# 定义

在面向对象软件设计过程中针对特定的问题的简洁而优雅的解决方案

通俗地说，设计模式就是给面向对象软件开发中的一些好的设计取个名字

# 动态类型语言

静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。

动态类型语言的优点是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。

duck typing,鸭子类型：如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。

在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。

原型编程思想中，类并不是必须的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。就像电影《的六日》一样，通过克隆可以创造另外一个一模一样的人，而且本体和克隆体看不出任何区别。

原型模式不单是一种设计模式，也被称为一种编程泛型。

原型编程泛型包括以下基本规则：
1. 所有的数据都是对象
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
3. 对象会记住它的原型。
4. 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。

# 第2章 this、call和apply

跟别的语言大相径庭的是，JavaScript 的 this总是指向一个对象，而具体指向哪个对象是运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。

指向大致分为下列四种
1.	作为对象的方法调用
2. 作为普通函数调用
3. 构造器调用
4. Function.prototype.call 或 Function.prototype.apply调用

当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window

可以借用Array.prototype.push方法的对象还要满足以下两个条件
1. 对象本身要可存取属性
2. 对象的length属性可读写


能够熟练使用call和apply，是我们真正成为一名JavaScript程序员的重要一步

# 第3章 高阶函数
1. 函数可以作为参数被传递
2. 函数可以作为返回值输出

函数柯里化

# 第4章 单例模式

核心：确保只有一个实例，并提供全局访问

单例是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更神奇的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力


# 第5章 策略模式

定义一系列的算法，把它们一个个封装起来，并且它们可以相互替换

# 第6章 代理模式
单一职责原则： 就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。

编写业务代码，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。

# 第7章 迭代器模式

迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。

# 第8章 发布-订阅模式

发布-订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代传统的发布-订阅模式。

发布-订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。

# 第9章 命令模式


# 第13章 职责链模式

无论是作用域链、原型链、还是DOM节点中的事件冒泡，我们都能从中找到职责链模式的影子。学会使用职责链模式，相信会在以后的代码编写中，大有裨益


# 第16章 状态模式

允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

状态模式的关键是把事物的每种状态都封装成单独的类，跟此状态有关的行为都被封装在这个类的内部，所以button被按下的时候，只需要在上下文中，把这个请求委托给当前的状态对象即可，该状态对象会负责渲染它自身的行为。

通过状态模式重构代码之后，很多杂乱无章的代码会变得清晰。虽然状态模式一开始并不是非常容易理解，但我们有必要去好好掌握这种设计模式。


# 第18章 单一职责原则
SRP原则体现为：一个对象（方法）只做一件事情
# 第20章 开放-封闭原则

软件实体（类、模块、函数）等应该是可扩展的

1. 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。
2. 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单。

# 第22章 代码重构

* 提炼函数

1. 避免出现超大函数
2. 独立出来的函数有助于代码复用
3. 独立出来的函数更容易覆写
4. 独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用

* 把条件分支语句提炼成函数
* 合理使用循环
* 提前让函数退出代替嵌套条件分支
* 传递对象参数代替过长的参数列表
* 尽量减少参数数量
* 少用三目运算符
* 合理使用链式调用（链式调用的坏处是难debug）
* 用return退出多重循环``